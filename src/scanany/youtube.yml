# Скрипт youtube.yml призначений для вибірки текстів повідомлень з ресурсу https://youtube.com за допомогою
# скрапера [scanany](https://github.com/boldak/scanany)

# Входить до складу проекту [@molfar](https://github.com/wdc-molfar)


# Відлагодження відбувається за допомою команди:

# ```sh
# npm run debug <path to script> [<path to settings>]
# ```

# Наприклад:

# ```sh
# npm run debug ./src/scanany/youtube.yml ./test/params/youtube.params.yml
# ```  

# Вхідні дані формуються планувальником завдань на основі оброблення бази даних медіа-джерел.

# Приклад вхідних даних (```./test/params/youtube.params.yml```):
# ```yaml
#options:
#  task:
#    params: ## from section source
#      url: UC-wWyFdk_txbZV8FKEk0V8A
#    instance: b940bfda-d145-4385-9dc6-c347dcd0fbcf ## scheduler instance   
#  scraper:
#    instance: b940bfda-d145-4385-9dc6-c347dcd0fbcf ## scraper instance   
#    scrapedAt: 2022-08-18T12:04:51.474Z     
# ```

# ** Опис алгоритму

# Використовуються плагіни ```axios-plugin``` для HTTP-запитів, ```cheerio-plugin```, ```js-plugin```
- use:     
    - axios-plugin
    - cheerio-plugin
    - js-plugin

# вибір даних із джерела
- map:
    # Визначення посилання на хост медіа-джерела (змінна ```url```)
    - $ref: options.task.params.url
      transform:
        apply:
          - js: (command, context, value) => `https://www.youtube.com/feeds/videos.xml?channel_id=${value}`
      into: url

# вибірка та оброблення сторінки зі стрічкою публікацій з використанням ```axios-plugin``` за адресою ```url``` 
- fetch:
    request:
      method: GET
      url: 
        $ref: url
    transform:
      apply:
        - project: data
        - html->$
    into: page

# вибірка із "page" всіх повідомлень (CSS-селектор ```entry```)
- all:
    $ref: page
    select: entry
    into: res

# оброблення елементів колекції ```res```   
- each:
    in:
      $ref: res
    as: item
    indexed-by: index
    into: messages
    
    # оброблення поточного елемента ```item```
    apply:
    
      - map:
          # поміщення ```options``` в ```res```
          - $ref: options
            into: res
      
          # перетворення item -> html -> объект cheerio
          # результат перетворення буде поміщений у ```msg```
          - $ref: item
            transform: 
              apply:
                - html
                - html->$
            into: msg

      # вибірка із "msg" назви відео (селектор ```media\:title```)
      - once:
          $ref: msg
          select: media\:title
          apply:
            # перетворення вибраного елемента в text та поміщення його в змінну ```d.title```  
            - transform: 
                apply:
                  - text
              into: d.title
            
            # перетворення вибраного елемента в html та поміщення його в змінну ```res.scraper.message.raw.html```
            - transform: html
              into: d.html.title

      # вибірка із "msg" опису відео (селектор ```media\:description```)
      - once:
          $ref: msg
          select: media\:description
          apply:
            # перетворення вибраного елемента в text та поміщення його в змінну ```d.description```  
            - transform: 
                apply:
                  - text
              into: d.description
            
            # перетворення вибраного елемента в html та поміщення його в змінну ```res.scraper.message.raw.html```
            - transform: html
              into: d.html.description
      
      # вибірка із  ```msg``` дати публікації в форматі iso (поле ```published```)
      - once:
          $ref: msg
          select: published
          apply:
          # перетворення вибраного елемента в text та поміщення його в змінну ```d.published```  
          - transform: 
              apply:
                - text
            into: d.published

      # вибірка із  ```msg``` поля з посиланням на зображення (поле ```media\:thumbnail```)
      - once:
          $ref: msg
          select: media\:thumbnail
          apply:
            # перетворення вибраного елемента в html та поміщення його в змінну ```d.images```  
            - transform: 
                apply:
                  - html
              into: d.images

      - map:

          # обє'днання назви відео (``title```) з описом відео (поле ```description```) із ```d```
          # та поміщення отриманого значення у ```res.scraper.message.text```
          - $ref: d
            transform:
              - js: (command, context, value) => `${value.title}\n${value.description}`
              - js: (command, context, value) => value.replace(/(\n)/g, " ")
            into: res.scraper.message.text

          # вибірка із ```d``` поля ```published``` та
          # поміщення результату в ```res.scraper.message.publishedAt```
          - $ref: d.published 
            into: res.scraper.message.publishedAt

          # обє'днання html поля ```html.title``` з ```html.description``` із ```d```
          # поміщення результату в ```res.scraper.message.raw.html```
          - $ref: d
            transform:
              js: (command, context, value) => `${value.html.title}\n${value.html.description}`
            into: res.scraper.message.raw.html

          # перетворення ```res.scraper.message.text``` в сигнатуру md5 та 
          # поміщення результату в ```res.scraper.message.md5```
          - $ref: res.scraper.message.text
            transform: md5
            into: res.scraper.message.md5

          # перетворення ```d.images``` в посилання на зображення та
          # поміщення результату в ```res.scraper.message.images[0]```
          - $ref: d.images
            transform:
              - js: (command, context, value) => value.match(/\http(.*)\.jpg\" width=/)[0]
              - js: (command, context, value) => value.replace("\" width=", "")
            into: res.scraper.message.images[0]

          # перетворення ```res.scraper.message.raw.html``` в список посиланнь та
          # поміщення результату в ```res.scraper.message.links```
          - $ref: res.scraper.message.raw.html
            transform:
              - js: >
                        (command, context, value) => { 
                          value = value.replace(/(\n)/g, " ")
                          value = value.match(/\http(.+?)\ /g)
                          if (value) {
                            var i = 0
                            var links = []
                              value.forEach(function(entry) {
                                links[i] = entry.replace(" ", "")
                                i = i + 1
                                })
                            }
                            return links
                          } 
            into: res.scraper.message.links

          # обчислення поточної дати в форматі iso та поміщення її у ```res.scraper.scrapedAt```
          - transform: date 
            into: res.scraper.scrapedAt
      
      # повернення результату оброблення поточного елемента ```item``` колекції ```res``` в ```res```
      - return: res

- return: messages